<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="../img/lhg_favicon.ico" />
    <title>Lufthansa Group – Agent Chat</title>

    <!-- Tailwind CDN (config with LH brand colors) -->
    <script>
      window.tailwind = {
        theme: {
          extend: {
            colors: {
              lhBlue: '#0B1F55',      // Lufthansa deep blue (approx)
              lhBlueDark: '#07163B',  // darker shade for header
              lhYellow: '#F7B500',    // Lufthansa yellow (approx)
              lhSlate: '#0E1B3A',
            }
          }
        }
      }
    </script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Inter font as clean, modern fallback -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <style>
      :root {
        --lh-blue: #0B1F55;
        --lh-blue-dark: #07163B;
        --lh-yellow: #F7B500;
      }
      body {
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        background-image: url('../img/dAisy-background.png');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-color: #0f172a;
      }
      .scroll-area { scroll-behavior: smooth; }
      code { background: rgba(255,255,255,0.08); padding: 0 .25rem; border-radius: .25rem; }
    </style>

    <!-- React (development UMD) + Babel for JSX inline; fine for a test rig -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="bg-[#0f172a] text-slate-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      const resolveInitialApiUrl = () => {
        try {
          const params = new URLSearchParams(window.location.search);
          const apiParam = params.get('api');
          if (apiParam) {
            localStorage.setItem('api_url', apiParam);
            return apiParam;
          }
        } catch (_) {}
        return localStorage.getItem('api_url') || 'https://origin-daisy.onrender.com/invoke';
      };

      // ---- Utilities ----
      const uid = () => (crypto.randomUUID ? crypto.randomUUID() : String(Date.now() + Math.random()));
      const DEFAULTS = {
        API_URL: resolveInitialApiUrl(),
      };
      const SETTINGS_VISIBLE = false;
      const MAX_COL = 250; // hard wrap width for logs

      function Header({ apiUrl, onOpenSettings, locationInfo, proxyOnline }) {
        const formattedTime = (() => {
          const reference = locationInfo?.localTime instanceof Date ? locationInfo.localTime : new Date(locationInfo?.localTime || Date.now());
          try {
            return reference.toLocaleString(undefined, locationInfo?.tz ? { timeZone: locationInfo.tz } : undefined);
          } catch (_) {
            return reference.toLocaleString();
          }
        })();
        const locationLabel = locationInfo?.label || "Detecting location…";
        const originLabel = locationInfo?.inferredOrigin ? ` · Default origin: ${locationInfo.inferredOrigin}` : '';
        const statusClass = proxyOnline ? 'bg-emerald-400' : 'bg-red-500';
        const statusTitle = proxyOnline ? 'Proxy online' : 'Proxy offline';
        return (
          <header className="sticky top-0 z-10 bg-lhBlueDark/95 backdrop-blur border-b border-white/10">
            <div className="max-w-5xl mx-auto px-4 py-3 flex items-center justify-between">
              <div className="flex items-center gap-[10px]">
                <img src="../img/imgbin_13fe065efcd84210aac1c831b51682b8.png" alt="Lufthansa Group" className="h-8 w-auto shrink-0" />
                <div>
                  <h1 className="text-sm font-semibold leading-tight tracking-wide text-white/90">Lufthansa Group</h1>
                  <p className="text-[11px] leading-tight text-white/60">Agent Chat · UI Test</p>
                </div>
              </div>

              <div className="flex items-center gap-2 text-xs text-white/70">
                <span className={`h-2.5 w-2.5 rounded-full ${statusClass}`} title={statusTitle}></span>
                <div className="text-right sm:text-left">
                  <div>{locationLabel}</div>
                  <div className="text-white/50">{formattedTime}{originLabel}</div>
                </div>
                {SETTINGS_VISIBLE && (
                  <button onClick={onOpenSettings} className="ml-2 text-sm px-3 py-1.5 rounded-lg bg-lhYellow text-lhBlue font-semibold hover:brightness-95 active:brightness-90 focus:outline-none focus:ring-2 focus:ring-white/40">
                    Settings
                  </button>
                )}
              </div>
            </div>
          </header>
        );
      }

      function SettingsModal({ open, onClose, apiUrl }) {
        if (!SETTINGS_VISIBLE || !open) return null;
        return (
          <div className="fixed inset-0 z-20 bg-black/60 grid place-items-center p-4">
            <div className="w-full max-w-xl rounded-2xl bg-slate-900 border border-white/10 shadow-xl">
              <div className="p-4 border-b border-white/10 flex items-center justify-between">
                <h2 className="text-base font-semibold">Connection</h2>
                <button onClick={onClose} className="text-white/70 hover:text-white">✕</button>
              </div>
              <div className="p-4 space-y-4">
                <label className="block text-sm">
                  <span className="block mb-1 text-white/70">Proxy URL (signs & forwards to Bedrock Agent)</span>
                  <input value={apiUrl} readOnly placeholder="https://origin-daisy.onrender.com/invoke" className="w-full bg-slate-800 border border-white/10 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-lhYellow/50 opacity-60 cursor-not-allowed" />
                </label>
                <p className="text-xs text-white/60">Tip: The UI POSTs <code>{"{ inputText, sessionId }"}</code> to the proxy and appends logs server-side.</p>
              </div>
              <div className="p-4 border-t border-white/10 flex justify-end">
                <button onClick={onClose} className="px-3 py-1.5 text-sm rounded-lg bg-white/10 hover:bg-white/15">Close</button>
              </div>
            </div>
          </div>
        );
      }

      function Bubble({ role, text, meta }) {
        const isUser = role === 'user';
        return (
          <div className={`w-full flex ${isUser ? 'justify-end' : 'justify-start'}`}>
            <div className={`max-w-[78%] rounded-2xl px-4 py-2.5 border ${isUser ? 'bg-lhYellow/95 text-lhBlue border-transparent' : 'bg-white/5 text-white/95 border-white/10'}`}>
              <p className="whitespace-pre-wrap text-sm leading-6">{text}</p>
              {meta ? <p className={`mt-1 text-[10px] ${isUser ? 'text-lhBlue/70' : 'text-white/50'}`}>{meta}</p> : null}
            </div>
          </div>
        );
      }

      function ChatApp() {
        // Refs & helpers
        const scrollRef = useRef(null);
        const usedFlightNos = useRef(new Set());
        const genFlightNo = () => {
          let n; do { n = Math.floor(Math.random() * 10000); } while (usedFlightNos.current.has(n));
          usedFlightNos.current.add(n); return `LH ${String(n).padStart(4, '0')}`;
        };

        // State
        const [apiUrl] = useState(DEFAULTS.API_URL);
        const [openSettings, setOpenSettings] = useState(false);
        const [sessionId] = useState(uid());
        const [startedAt] = useState(() => new Date());
        const [flightNo] = useState(genFlightNo()); // fixed per session; new on refresh
        const [busy, setBusy] = useState(false);
        const [input, setInput] = useState('');
        const [messages, setMessages] = useState([
          { id: uid(), role: 'assistant', text: 'Lufthansa Group Inspirational AI flight assistant. Nice to meet you!”', ts: new Date().toISOString() }
        ]);

        const deriveLookupUrl = (base) => {
          try {
            const url = new URL(base);
            if (url.pathname.endsWith('/invoke')) {
              url.pathname = url.pathname.replace(/\/invoke$/, '/tools/iata/lookup');
            } else {
              url.pathname = '/tools/iata/lookup';
            }
            url.search = '';
            return url.toString();
          } catch (_) {
            return null;
          }
        };

        const lookupUrl = deriveLookupUrl(apiUrl);
        const [locationInfo, setLocationInfo] = useState({
          label: 'Detecting location…',
          tz: Intl.DateTimeFormat().resolvedOptions().timeZone,
          localTime: new Date(),
          inferredOrigin: localStorage.getItem('inferred_origin') || null,
        });

        const [proxyOnline, setProxyOnline] = useState(true);
        const locationHintSentRef = useRef(null);

        // Server-append state
        const headerSentRef = useRef(false);
        const savedCountRef = useRef(0); // messages already flushed to server

        // Auto-scroll
        useEffect(() => {
          if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
        }, [messages, busy]);

        // Tests
        useEffect(() => { console.assert(/^LH \d{4}$/.test(flightNo), 'Flight number format invalid', flightNo); }, [flightNo]);

        useEffect(() => {
          const timer = setInterval(() => {
            setLocationInfo(prev => ({ ...prev, localTime: new Date() }));
          }, 1000);
          return () => clearInterval(timer);
        }, []);

        useEffect(() => {
          const inferIata = async (input) => {
            if (!lookupUrl) return null;
            let term = '';
            let lat;
            let lon;
            if (typeof input === 'string') {
              term = input.trim();
            } else if (input && typeof input === 'object') {
              const termCandidates = [input.term, input.city, input.country];
              for (const candidate of termCandidates) {
                if (typeof candidate === 'string' && !term) {
                  const trimmed = candidate.trim();
                  if (trimmed) term = trimmed;
                }
              }
              const latCandidate = Number(input.lat ?? input.latitude);
              const lonCandidate = Number(input.lon ?? input.longitude);
              if (Number.isFinite(latCandidate) && Number.isFinite(lonCandidate)) {
                lat = latCandidate;
                lon = lonCandidate;
              }
            }
            const hasTerm = term.length > 0;
            const hasCoords = Number.isFinite(lat) && Number.isFinite(lon);
            if (!hasTerm && !hasCoords) return null;
            const params = new URLSearchParams();
            if (hasTerm) params.set('term', term);
            if (hasCoords) {
              params.set('lat', lat.toFixed(6));
              params.set('lon', lon.toFixed(6));
            }
            params.set('limit', '5');
            try {
              const res = await fetch(`${lookupUrl}?${params.toString()}`);
              if (!res.ok) {
                setProxyOnline(true);
                return null;
              }
              setProxyOnline(true);
              const data = await res.json();
              const match = (data.matches || [])[0];
              return match?.code || null;
            } catch {
              setProxyOnline(false);
              return null;
            }
          };

          const applyLocation = (label, tz, inferred) => {
            setLocationInfo(prev => ({
              ...prev,
              label,
              tz: tz || prev.tz,
              localTime: new Date(),
              inferredOrigin: inferred || prev.inferredOrigin || null,
            }));
            if (inferred) {
              localStorage.setItem('inferred_origin', inferred);
            }
          };

          const updateFromCoords = async (lat, lon) => {
            try {
              const resp = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=en`);
              if (!resp.ok) throw new Error('reverse');
              const data = await resp.json();
              const locality = data.city || data.locality || data.principalSubdivision || '';
              const country = data.countryName || data.countryCode || '';
              const label = [locality, country].filter(Boolean).join(', ') || 'Current location';
              let inferred = await inferIata({ lat, lon, term: locality });
              if (!inferred && country) inferred = await inferIata({ term: country });
              applyLocation(label, Intl.DateTimeFormat().resolvedOptions().timeZone, inferred);
              return true;
            } catch {
              return false;
            }
          };

          const fetchIpLocation = async () => {
            try {
              const resp = await fetch('https://ipapi.co/json/');
              if (!resp.ok) throw new Error('geo');
              const data = await resp.json();
              const city = data.city;
              const region = data.region;
              const country = data.country_name || data.country;
              const tz = data.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
              const label = [city, region, country].filter(Boolean).join(', ') || 'Approximate location';
              const lat = Number(data.latitude);
              const lon = Number(data.longitude);
              let inferred = await inferIata({ term: city, lat, lon });
              if (!inferred && country) inferred = await inferIata({ term: country });
              applyLocation(label, tz, inferred);
            } catch {
              applyLocation('Location unavailable', Intl.DateTimeFormat().resolvedOptions().timeZone, null);
            }
          };

          const resolveLocation = async () => {
            if ('geolocation' in navigator) {
              const success = await new Promise(resolve => {
                navigator.geolocation.getCurrentPosition(
                  async pos => {
                    const handled = await updateFromCoords(pos.coords.latitude, pos.coords.longitude);
                    resolve(handled);
                  },
                  async () => {
                    resolve(false);
                  },
                  { enableHighAccuracy: false, timeout: 5000, maximumAge: 600000 }
                );
              });
              if (success) return;
            }
            await fetchIpLocation();
          };

          resolveLocation();
        }, [lookupUrl]);

        // ===== Log formatting tools =====
        const tsStr = (iso) => `[${iso}]`;
        const baseIndent = (iso) => ' '.repeat(tsStr(iso).length + 1); // after timestamp + one space

        const isBulletLine = (line) => /^\s*(?:[-*+]|\d+[.)])\s+/.test(line);

        const tokenizeBlocks = (raw) => {
          const out = [];
          const norm = String(raw || '').replace(/\r\n?/g, '\n');
          const lines = norm.split('\n');
          let i = 0;
          while (i < lines.length) {
            if (lines[i].trim() === '') { i++; continue; }
            if (isBulletLine(lines[i])) {
              const items = [];
              while (i < lines.length && isBulletLine(lines[i])) {
                const m = lines[i].match(/^\s*((?:[-*+])|(?:\d+[.)]))\s+(.*)$/);
                const marker = m?.[1] || '-';
                const text = (m?.[2] || '').trim();
                items.push({ marker, text });
                i++;
              }
              out.push({ type: 'list', items });
            } else {
              let buf = lines[i].trim();
              i++;
              while (i < lines.length && lines[i].trim() !== '' && !isBulletLine(lines[i])) {
                buf += ' ' + lines[i].trim();
                i++;
              }
              out.push({ type: 'text', text: buf });
            }
          }
          return out;
        };

        const wrapWithIndent = (content, firstPrefix, contIndent) => {
          const words = String(content || '').split(/\s+/).filter(Boolean);
          const firstAvail = Math.max(10, MAX_COL - firstPrefix.length);
          const nextAvail = Math.max(10, MAX_COL - contIndent.length);
          const lines = [];
          let cur = '';
          let avail = firstAvail;
          const pushLine = (prefix, text) => lines.push(prefix + text);
          for (const w of words) {
            if (cur.length === 0) {
              if (w.length > avail) {
                // hard-break very long token
                pushLine(lines.length === 0 ? firstPrefix : contIndent, w.slice(0, avail));
                let rest = w.slice(avail);
                while (rest.length > 0) {
                  const take = Math.min(nextAvail, rest.length);
                  pushLine(contIndent, rest.slice(0, take));
                  rest = rest.slice(take);
                }
                avail = nextAvail; cur = '';
              } else {
                cur = w;
              }
            } else if (cur.length + 1 + w.length <= avail) {
              cur += ' ' + w;
            } else {
              pushLine(lines.length === 0 ? firstPrefix : contIndent, cur);
              cur = w;
              avail = nextAvail;
            }
          }
          if (cur) pushLine(lines.length === 0 ? firstPrefix : contIndent, cur);
          return lines.join('\n');
        };

        const formatEntry = (m) => {
          const iso = m.ts || new Date().toISOString();
          const role = (m.role || 'assistant').toUpperCase();
          const ts = tsStr(iso);
          const head = `${ts} ${role}: `; // first line prefix
          const indent = baseIndent(iso); // continuation lines start after timestamp + space
          const blocks = tokenizeBlocks(m.text);
          const out = [];

          if (blocks.length === 0) {
            out.push(head); // empty line with header only
            return out.join('\n');
          }

          // Process blocks
          let firstPiece = true;
          for (const b of blocks) {
            if (b.type === 'text') {
              const prefix = firstPiece ? head : indent; // no role repeat after first line of entry
              out.push(wrapWithIndent(b.text, prefix, indent));
              firstPiece = false;
            } else if (b.type === 'list') {
              b.items.forEach((it, idx) => {
                const bullet = String(it.marker);
                const bulletPad = ' '.repeat(bullet.length + 1);
                const firstPrefix = (firstPiece && idx === 0) ? (head + bullet + ' ') : (indent + bullet + ' ');
                const cont = indent + bulletPad; // indent continuation under the text of list item
                out.push(wrapWithIndent(it.text, firstPrefix, cont));
                firstPiece = false;
              });
            }
          }
          return out.join('\n');
        };

        const buildHeader = () => [
          `FLIGHT: ${flightNo.replace(' ', '')}`,
          `SESSION: ${sessionId}`,
          `STARTED: ${startedAt.toISOString()}`,
          '---'
        ].join('\n');

        const buildFullLog = () => {
          const lines = [buildHeader()];
          for (const m of messages) lines.push(formatEntry(m));
          return lines.join('\n') + '\n';
        };

        // ---- Append to server (/log.php) ----
        const appendToServer = async () => {
          try {
            const filename = flightNo.replace(' ', '') + '.log';
            let chunk = '';
            if (!headerSentRef.current) {
              chunk += buildHeader() + '\n';
              headerSentRef.current = true;
            }
            if (messages.length > savedCountRef.current) {
              const news = messages.slice(savedCountRef.current).map(formatEntry).join('\n');
              if (news) chunk += news + '\n';
              savedCountRef.current = messages.length;
            }
            if (!chunk) return;
            await fetch('/log.php', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ filename, chunk })
            });
          } catch (e) {
            console.warn('Server log append failed', e);
          }
        };

        // First write (header + initial assistant message)
        useEffect(() => { appendToServer(); }, []);

        const downloadLog = () => {
          const blob = new Blob([buildFullLog()], { type: 'text/plain' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = flightNo.replace(' ', '') + '.log';
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(() => URL.revokeObjectURL(a.href), 0);
        };

        // ---- Chat send ----
        const send = async () => {
          const text = input.trim();
          if (!text || busy) return;
          setInput('');
          const userMsg = { id: uid(), role: 'user', text, ts: new Date().toISOString() };
          setMessages(m => [...m, userMsg]);

          setBusy(true);
          try {
            let payloadText = text;
            const originCode = locationInfo?.inferredOrigin;
            if (originCode) {
              const alreadySent = locationHintSentRef.current;
              if (alreadySent !== originCode) {
                const labelText = locationInfo?.label;
                const originLabel = labelText && !/detecting/i.test(labelText) ? ` (${labelText})` : '';
                const contextLine = `SYSTEM CONTEXT: Default departure airport inferred via UI geolocation is ${originCode}${originLabel}. Use this origin unless the traveler specifies a different one.`;
                payloadText = `${contextLine}\n\n${payloadText}`;
                locationHintSentRef.current = originCode;
              }
            }
            const payload = { inputText: payloadText, sessionId };
            const res = await fetch(apiUrl, {
              method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            });
            if (!res.ok) {
              const httpError = new Error(`Proxy error ${res.status}`);
              httpError.isHttpError = true;
              throw httpError;
            }
            setProxyOnline(true);
            const data = await res.json();
            const reply = (data.text || data.responseText || data.answer || '').trim();
            const meta = data.cid ? `cid ${data.cid}` : undefined;
            const botMsg = { id: uid(), role: 'assistant', text: reply || 'No text response.', meta, ts: new Date().toISOString() };
            setMessages(m => [...m, botMsg]);
          } catch (err) {
            if (!err?.isHttpError) {
              setProxyOnline(false);
            }
            const errMsg = { id: uid(), role: 'assistant', text: `Error: ${err.message}. Check proxy logs.`, meta: 'client', ts: new Date().toISOString() };
            setMessages(m => [...m, errMsg]);
          } finally {
            setBusy(false);
            setTimeout(appendToServer, 0);
          }
        };

        const onKeyDown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); send(); } };

        return (
          <div className="min-h-screen grid grid-rows-[auto,1fr,auto] bg-gradient-to-b from-lhBlueDark to-[#0b1229]">
            <Header apiUrl={apiUrl} onOpenSettings={SETTINGS_VISIBLE ? () => setOpenSettings(true) : () => {}} locationInfo={locationInfo} proxyOnline={proxyOnline} />

            <main className="max-w-5xl mx-auto w-full px-4 py-6">
              <div ref={scrollRef} className="scroll-area h-[66vh] sm:h-[70vh] rounded-2xl bg-slate-900/60 border border-white/10 p-4 overflow-y-auto space-y-3">
                {messages.map(m => (
                  <Bubble key={m.id} role={m.role} text={m.text} meta={m.meta} />
                ))}
                {busy && (
                  <div className="flex items-center gap-2 text-white/70 text-sm">
                    <span className="relative flex h-2 w-2"><span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-lhYellow opacity-75"></span><span className="relative inline-flex rounded-full h-2 w-2 bg-lhYellow"></span></span>
                    <span>Contacting agent…</span>
                  </div>
                )}
              </div>
            </main>

            {/* Flight number & download only */}
            <section className="max-w-5xl mx-auto w-full px-4 pb-3">
              <div className="flex items-center justify-between gap-2 rounded-xl border border-white/10 bg-white/[0.06] px-4 py-3">
                <div className="flex items-center gap-[10px]">
                  <span className="text-xs uppercase tracking-wide text-white/60">Flight number</span>
                  <span className="inline-flex items-center gap-[10px] text-base font-semibold text-lhBlue bg-lhYellow px-3 py-1.5 rounded-xl">
                    <img src="../img/imgbin_13fe065efcd84210aac1c831b51682b8.png" alt="Flight icon" className="h-5 w-auto" />
                    {flightNo}
                  </span>
                </div>
                <button onClick={downloadLog} className="px-3 py-1.5 text-xs rounded-lg bg-white/10 hover:bg-white/15 border border-white/10">Download log</button>
              </div>
            </section>

            <footer className="max-w-5xl mx-auto w-full px-4 pb-6">
              <div className="bg-slate-900/80 border border-white/10 rounded-2xl p-2 flex items-end gap-2">
                <textarea
                  value={input}
                  onChange={e => setInput(e.target.value)}
                  onKeyDown={onKeyDown}
                  placeholder="Type your message… (Shift+Enter for newline)"
                  className="flex-1 bg-transparent outline-none resize-none text-sm leading-6 placeholder:text-white/40 px-3 py-2 h-[52px] max-h-[160px]"
                />
                <button onClick={send} disabled={busy} className="shrink-0 inline-flex items-center gap-2 px-4 py-2 rounded-xl font-semibold bg-lhYellow text-lhBlue hover:brightness-95 active:brightness-90 disabled:opacity-60">
                  <svg viewBox="0 0 24 24" className="w-5 h-5" fill="currentColor"><path d="M2 3l20 9-20 9 5-9-5-9zm7.2 9l-2.5 4.5L18 12 6.7 6.5 9.2 11H22"/></svg>
                  Send
                </button>
              </div>
            </footer>

            <SettingsModal open={openSettings} onClose={() => setOpenSettings(false)} apiUrl={apiUrl} />
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<ChatApp />);
    </script>
  </body>
</html>
